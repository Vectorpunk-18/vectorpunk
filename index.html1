<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VectorPunk | Robot Run</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @font-face {
            font-family: 'Pixel';
            src: url('https://fonts.cdnfonts.com/s/17215/PressStart2P-Regular.woff') format('woff');
        }
        body {
            background-color: #050505;
            color: #fff;
            font-family: 'Pixel', monospace;
            overflow: hidden;
            touch-action: none;
        }
        .scanline {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen select-none">

    <div class="scanline"></div>

    <div class="absolute top-10 text-center z-20">
        <h1 class="text-xs text-zinc-500 mb-2 tracking-widest">PROTOCOL: SURVIVE</h1>
        <div class="text-4xl text-cyan-400" id="score">0000</div>
        <div id="start-msg" class="mt-4 text-xs animate-pulse text-zinc-400">PRESS SPACE OR TAP TO START</div>
    </div>

    <div class="relative border-b-2 border-zinc-800 w-full max-w-3xl h-[300px] overflow-hidden bg-zinc-900/20">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="mt-8 text-zinc-600 text-[10px] uppercase tracking-widest">
        VectorPunk System
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationId;

        // Resize handling
        function resize() {
            canvas.width = Math.min(window.innerWidth, 800);
            canvas.height = 300;
        }
        window.addEventListener('resize', resize);
        resize();

        // Game State
        let gameSpeed = 5;
        let score = 0;
        let isPlaying = false;
        let gravity = 0.6;
        let obstacles = [];

        // Robot Object
        const robot = {
            x: 50,
            y: 200,
            w: 30, // visual width
            h: 40, // visual height
            dy: 0,
            jumpForce: -11,
            grounded: false,
            color: '#ffffff',
            
            draw: function() {
                // Draw Pixel Robot Manually
                ctx.fillStyle = this.color;
                
                // Head
                ctx.fillRect(this.x + 5, this.y, 20, 15);
                // Eyes (Glowing Cyan)
                ctx.fillStyle = '#22d3ee'; 
                ctx.fillRect(this.x + 8, this.y + 4, 4, 4);
                ctx.fillRect(this.x + 18, this.y + 4, 4, 4);
                
                // Body
                ctx.fillStyle = '#d4d4d8';
                ctx.fillRect(this.x, this.y + 16, 30, 18);
                // Chest piece
                ctx.fillStyle = '#3f3f46';
                ctx.fillRect(this.x + 8, this.y + 20, 14, 10);

                // Legs (animated roughly)
                ctx.fillStyle = '#a1a1aa';
                if(this.grounded && Math.floor(score/5) % 2 === 0) {
                    ctx.fillRect(this.x + 2, this.y + 34, 8, 6); // Left leg
                    ctx.fillRect(this.x + 20, this.y + 34, 8, 6); // Right leg
                } else {
                    ctx.fillRect(this.x + 4, this.y + 34, 8, 4); // Left leg up
                    ctx.fillRect(this.x + 18, this.y + 34, 8, 8); // Right leg down
                }
            },
            
            jump: function() {
                if (this.grounded) {
                    this.dy = this.jumpForce;
                    this.grounded = false;
                }
            },
            
            update: function() {
                // Physics
                if (isPlaying) {
                    this.dy += gravity;
                    this.y += this.dy;
                }

                // Ground Collision
                if (this.y + this.h > canvas.height - 20) {
                    this.y = canvas.height - 20 - this.h;
                    this.dy = 0;
                    this.grounded = true;
                } else {
                    this.grounded = false;
                }

                this.draw();
            }
        };

        class Obstacle {
            constructor() {
                this.w = 20 + Math.random() * 20;
                this.h = 30 + Math.random() * 20;
                this.x = canvas.width;
                this.y = canvas.height - 20 - this.h;
                this.marked = false;
            }

            update() {
                this.x -= gameSpeed;
                
                // Tech visual style for obstacle
                ctx.fillStyle = '#ef4444'; // Red danger
                ctx.shadowColor = '#ef4444';
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // Glitch effect on obstacle
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 5, this.y + 5, this.w - 10, this.h - 10);
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(this.x + 10, this.y + 10, this.w - 20, this.h - 20);
            }
        }

        function spawnObstacle() {
            if (!isPlaying) return;
            let size = Math.random() * (canvas.width - 500) + 500; // Random distance
            obstacles.push(new Obstacle());
        }

        // Main Loop
        let timer = 0;
        function animate() {
            animationId = requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Ground Line
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height - 20);
            ctx.strokeStyle = '#3f3f46';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (isPlaying) {
                timer++;
                score++;
                document.getElementById('score').innerText = score.toString().padStart(4, '0');
                
                // Speed up slightly
                if (score % 500 === 0) gameSpeed += 0.5;

                // Spawn logic
                if (timer > 100 - (gameSpeed * 2) && Math.random() > 0.5) {
                    spawnObstacle();
                    timer = 0;
                }
            }

            robot.update();

            // Obstacles Logic
            for (let i = 0; i < obstacles.length; i++) {
                obstacles[i].update();

                // Collision Detection
                if (
                    robot.x < obstacles[i].x + obstacles[i].w &&
                    robot.x + robot.w > obstacles[i].x &&
                    robot.y < obstacles[i].y + obstacles[i].h &&
                    robot.y + robot.h > obstacles[i].y
                ) {
                    gameOver();
                }

                // Cleanup
                if (obstacles[i].x + obstacles[i].w < 0) {
                    obstacles.splice(i, 1);
                    i--;
                }
            }
        }

        function gameOver() {
            isPlaying = false;
            gameSpeed = 5;
            document.getElementById('start-msg').innerText = "SYSTEM FAILURE. TAP TO REBOOT.";
            document.getElementById('start-msg').classList.remove('hidden');
        }

        function resetGame() {
            obstacles = [];
            score = 0;
            timer = 0;
            gameSpeed = 5;
            robot.y = 200;
            robot.dy = 0;
            isPlaying = true;
            document.getElementById('start-msg').innerText = "";
        }

        // Controls
        function handleInput(e) {
            // Prevent default scrolling on spacebar
            if(e.type === 'keydown' && e.code === 'Space') {
                 e.preventDefault(); 
            }
            
            if (!isPlaying) {
                if(obstacles.length > 0 || score > 0) resetGame();
                else isPlaying = true; document.getElementById('start-msg').innerText = "";
            } else {
                robot.jump();
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput(e);
        });
        window.addEventListener('touchstart', handleInput);
        window.addEventListener('mousedown', handleInput);

        animate();
    </script>
</body>
</html>